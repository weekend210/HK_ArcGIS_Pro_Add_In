# 香港适宜建设土地选址工具 - 界面代码设计方案（改进版 - 动态空行）

## 改进说明

本方案针对原方案中**固定行数**的问题进行了改进，实现了**真正的动态空行添加**功能：

- ✅ **约束条件**：当最后一个空白行被填充后，自动添加新的空白行
- ✅ **POI数据**：当最后一个空白行被填充后，自动添加新的空白行
- ✅ **无限扩展**：理论上可以添加无限个输入数据
- ✅ **空白行过滤**：分析时自动过滤空白行，不参与计算

---

## 一、核心改进点

### 1.1 问题分析

原方案的问题：
```csharp
// ❌ 错误：初始化时固定了5行约束条件和2行POI
ConstraintItems = new ObservableCollection<ConstraintDataItem>();
for (int i = 0; i < 5; i++)
{
    ConstraintItems.Add(new ConstraintDataItem());
}
```

### 1.2 改进方案

**核心思路**：
1. 初始化时只添加**1个空白行**
2. 监听每个数据项的 `PropertyChanged` 事件
3. 当某个空白行的 `DataPath` 被赋值时，检查是否需要添加新空白行
4. **只在集合末尾保持1个空白行**

---

## 二、改进后的数据模型

### 2.1 约束条件数据项 (ConstraintDataItem.cs)

```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace HK_AREA_SEARCH.Models
{
    /// <summary>
    /// 约束条件数据项模型（支持动态空行）
    /// </summary>
    public class ConstraintDataItem : INotifyPropertyChanged
    {
        private string _dataPath;
        private string _dataName;

        /// <summary>
        /// 数据文件路径
        /// </summary>
        public string DataPath
        {
            get => _dataPath;
            set
            {
                if (_dataPath != value)
                {
                    _dataPath = value;
                    OnPropertyChanged();

                    // 自动提取文件名
                    if (!string.IsNullOrWhiteSpace(value))
                    {
                        DataName = System.IO.Path.GetFileNameWithoutExtension(value);
                    }
                    else
                    {
                        DataName = string.Empty;
                    }
                }
            }
        }

        /// <summary>
        /// 数据名称（显示用）
        /// </summary>
        public string DataName
        {
            get => _dataName;
            set
            {
                if (_dataName != value)
                {
                    _dataName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// 是否为空白行
        /// </summary>
        public bool IsEmpty => string.IsNullOrWhiteSpace(DataPath);

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

### 2.2 POI数据项 (POIDataItem.cs)

```csharp
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace HK_AREA_SEARCH.Models
{
    /// <summary>
    /// POI数据项模型（支持动态空行）
    /// </summary>
    public class POIDataItem : INotifyPropertyChanged
    {
        private string _dataPath;
        private string _dataName;
        private int? _distance;
        private double? _weight;
        private bool _customInterval;
        private bool _isRasterData;

        /// <summary>
        /// 输入数据路径
        /// </summary>
        public string DataPath
        {
            get => _dataPath;
            set
            {
                if (_dataPath != value)
                {
                    _dataPath = value;
                    OnPropertyChanged();

                    if (!string.IsNullOrWhiteSpace(value))
                    {
                        DataName = System.IO.Path.GetFileNameWithoutExtension(value);

                        // 判断是否为栅格数据
                        var ext = System.IO.Path.GetExtension(value)?.ToLower();
                        IsRasterData = ext == ".tif" || ext == ".tiff" || ext == ".img";
                    }
                    else
                    {
                        DataName = string.Empty;
                        IsRasterData = false;
                    }
                }
            }
        }

        /// <summary>
        /// 数据名称
        /// </summary>
        public string DataName
        {
            get => _dataName;
            set
            {
                if (_dataName != value)
                {
                    _dataName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// 距离（米），正数或负数
        /// </summary>
        public int? Distance
        {
            get => _distance;
            set
            {
                // 如果是栅格数据，强制为空
                if (IsRasterData)
                {
                    _distance = null;
                }
                else
                {
                    _distance = value;
                }
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// 权重（小于1.0的浮点数，保留两位小数）
        /// </summary>
        public double? Weight
        {
            get => _weight;
            set
            {
                if (value.HasValue)
                {
                    _weight = Math.Round(value.Value, 2);
                }
                else
                {
                    _weight = value;
                }
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// 是否自定义距离间隔
        /// </summary>
        public bool CustomInterval
        {
            get => _customInterval;
            set
            {
                if (_customInterval != value)
                {
                    _customInterval = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// 是否为栅格数据
        /// </summary>
        public bool IsRasterData
        {
            get => _isRasterData;
            private set
            {
                if (_isRasterData != value)
                {
                    _isRasterData = value;
                    OnPropertyChanged();
                    OnPropertyChanged(nameof(IsDistanceEnabled));

                    // 如果是栅格数据，清空距离
                    if (_isRasterData)
                    {
                        Distance = null;
                    }
                }
            }
        }

        /// <summary>
        /// 距离字段是否可编辑
        /// </summary>
        public bool IsDistanceEnabled => !IsRasterData;

        /// <summary>
        /// 是否为空白行
        /// </summary>
        public bool IsEmpty => string.IsNullOrWhiteSpace(DataPath);

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

### 2.3 分类间隔项 (IntervalClassItem.cs)

```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace HK_AREA_SEARCH.Models
{
    /// <summary>
    /// 分类间隔项模型（用于自定义距离间隔对话框）
    /// </summary>
    public class IntervalClassItem : INotifyPropertyChanged
    {
        private double _startValue;
        private double _endValue;
        private int _classValue;

        /// <summary>
        /// 开始值
        /// </summary>
        public double StartValue
        {
            get => _startValue;
            set
            {
                if (_startValue != value)
                {
                    _startValue = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// 结束值
        /// </summary>
        public double EndValue
        {
            get => _endValue;
            set
            {
                if (_endValue != value)
                {
                    _endValue = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// 类别值（0-10或10-0）
        /// </summary>
        public int ClassValue
        {
            get => _classValue;
            set
            {
                if (_classValue != value)
                {
                    _classValue = value;
                    OnPropertyChanged();
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

---

## 三、改进后的ViewModel (main_dockpaneViewModel.cs)

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows.Input;
using Microsoft.Win32;
using ArcGIS.Desktop.Framework;
using ArcGIS.Desktop.Framework.Contracts;
using ArcGIS.Desktop.Framework.Dialogs;
using HK_AREA_SEARCH.Models;

namespace HK_AREA_SEARCH
{
    internal class main_dockpaneViewModel : DockPane
    {
        private const string _dockPaneID = "HK_AREA_SEARCH_main_dockpane";

        #region 属性

        private string _heading = "香港选址工具";
        public string Heading
        {
            get { return _heading; }
            set { SetProperty(ref _heading, value, () => Heading); }
        }

        /// <summary>
        /// 约束条件数据集合
        /// </summary>
        private ObservableCollection<ConstraintDataItem> _constraintItems;
        public ObservableCollection<ConstraintDataItem> ConstraintItems
        {
            get { return _constraintItems; }
            set { SetProperty(ref _constraintItems, value, () => ConstraintItems); }
        }

        /// <summary>
        /// 分析区域路径
        /// </summary>
        private string _analysisAreaPath;
        public string AnalysisAreaPath
        {
            get { return _analysisAreaPath; }
            set { SetProperty(ref _analysisAreaPath, value, () => AnalysisAreaPath); }
        }

        /// <summary>
        /// POI数据集合
        /// </summary>
        private ObservableCollection<POIDataItem> _poiItems;
        public ObservableCollection<POIDataItem> POIItems
        {
            get { return _poiItems; }
            set { SetProperty(ref _poiItems, value, () => POIItems); }
        }

        /// <summary>
        /// 输出路径
        /// </summary>
        private string _outputPath;
        public string OutputPath
        {
            get { return _outputPath; }
            set { SetProperty(ref _outputPath, value, () => OutputPath); }
        }

        /// <summary>
        /// 权重和验证消息
        /// </summary>
        private string _weightSumValidationMessage;
        public string WeightSumValidationMessage
        {
            get { return _weightSumValidationMessage; }
            set { SetProperty(ref _weightSumValidationMessage, value, () => WeightSumValidationMessage); }
        }

        /// <summary>
        /// 权重和是否有效
        /// </summary>
        private bool _isWeightSumValid;
        public bool IsWeightSumValid
        {
            get { return _isWeightSumValid; }
            set { SetProperty(ref _isWeightSumValid, value, () => IsWeightSumValid); }
        }

        #endregion

        #region 命令

        public ICommand BrowseConstraintCommand { get; private set; }
        public ICommand BrowseAnalysisAreaCommand { get; private set; }
        public ICommand BrowsePOICommand { get; private set; }
        public ICommand BrowseOutputCommand { get; private set; }
        public ICommand RunAnalysisCommand { get; private set; }

        #endregion

        #region 构造函数

        protected main_dockpaneViewModel()
        {
            InitializeCollections();
            InitializeCommands();
        }

        /// <summary>
        /// 初始化集合（关键改进：只添加1个空白行）
        /// </summary>
        private void InitializeCollections()
        {
            // 初始化约束条件集合（只添加1个空白行）
            ConstraintItems = new ObservableCollection<ConstraintDataItem>();
            AddEmptyConstraintRow();

            // 初始化POI集合（只添加1个空白行）
            POIItems = new ObservableCollection<POIDataItem>();
            AddEmptyPOIRow();
        }

        private void InitializeCommands()
        {
            BrowseConstraintCommand = new RelayCommand(BrowseConstraintData, (object parameter) => true);
            BrowseAnalysisAreaCommand = new RelayCommand(BrowseAnalysisArea, (object parameter) => true);
            BrowsePOICommand = new RelayCommand(BrowsePOIData, (object parameter) => true);
            BrowseOutputCommand = new RelayCommand(BrowseOutputPath, (object parameter) => true);
            RunAnalysisCommand = new RelayCommand(RunAnalysis, CanRunAnalysis);
        }

        #endregion

        #region 动态空行管理（关键改进）

        /// <summary>
        /// 添加空白约束条件行，并订阅属性变化事件
        /// </summary>
        private void AddEmptyConstraintRow()
        {
            var newItem = new ConstraintDataItem();

            // 订阅属性变化事件
            newItem.PropertyChanged += (sender, e) =>
            {
                if (e.PropertyName == nameof(ConstraintDataItem.DataPath))
                {
                    CheckAndAddEmptyConstraintRow();
                }
            };

            ConstraintItems.Add(newItem);
        }

        /// <summary>
        /// 添加空白POI行，并订阅属性变化事件
        /// </summary>
        private void AddEmptyPOIRow()
        {
            var newItem = new POIDataItem();

            // 订阅属性变化事件
            newItem.PropertyChanged += (sender, e) =>
            {
                if (e.PropertyName == nameof(POIDataItem.DataPath))
                {
                    CheckAndAddEmptyPOIRow();
                }

                // 权重变化时验证总和
                if (e.PropertyName == nameof(POIDataItem.Weight))
                {
                    ValidateWeightSum();
                }
            };

            POIItems.Add(newItem);
        }

        /// <summary>
        /// 检查并添加空白约束条件行
        /// </summary>
        private void CheckAndAddEmptyConstraintRow()
        {
            // 检查最后一行是否为空白行
            var lastItem = ConstraintItems.LastOrDefault();

            if (lastItem != null && !lastItem.IsEmpty)
            {
                // 最后一行已被填充，添加新空白行
                AddEmptyConstraintRow();
            }
        }

        /// <summary>
        /// 检查并添加空白POI行
        /// </summary>
        private void CheckAndAddEmptyPOIRow()
        {
            // 检查最后一行是否为空白行
            var lastItem = POIItems.LastOrDefault();

            if (lastItem != null && !lastItem.IsEmpty)
            {
                // 最后一行已被填充，添加新空白行
                AddEmptyPOIRow();
            }
        }

        #endregion

        #region 方法

        /// <summary>
        /// 验证权重和
        /// </summary>
        private void ValidateWeightSum()
        {
            var nonEmptyItems = POIItems.Where(p => !p.IsEmpty && p.Weight.HasValue).ToList();

            if (nonEmptyItems.Count == 0)
            {
                IsWeightSumValid = false;
                WeightSumValidationMessage = "";
                return;
            }

            double sum = nonEmptyItems.Sum(p => p.Weight.Value);

            if (Math.Abs(sum - 1.0) > 0.001) // 允许0.001的误差
            {
                IsWeightSumValid = true; // 显示消息
                WeightSumValidationMessage = $"警告: 权重之和为 {sum:F2}，应为 1.0";
            }
            else
            {
                IsWeightSumValid = false; // 隐藏消息
                WeightSumValidationMessage = "";
            }
        }

        /// <summary>
        /// 浏览约束条件数据
        /// </summary>
        private void BrowseConstraintData(object parameter)
        {
            var item = parameter as ConstraintDataItem;
            if (item == null) return;

            var dialog = new OpenFileDialog
            {
                Filter = "Shapefile (*.shp)|*.shp|GeoDatabase Feature Class|*.gdb|All Files (*.*)|*.*",
                Title = "选择约束条件数据"
            };

            if (dialog.ShowDialog() == true)
            {
                item.DataPath = dialog.FileName;
            }
        }

        /// <summary>
        /// 浏览分析区域
        /// </summary>
        private void BrowseAnalysisArea(object parameter)
        {
            var dialog = new OpenFileDialog
            {
                Filter = "Shapefile (*.shp)|*.shp|GeoDatabase Feature Class|*.gdb|All Files (*.*)|*.*",
                Title = "选择分析区域"
            };

            if (dialog.ShowDialog() == true)
            {
                AnalysisAreaPath = dialog.FileName;
            }
        }

        /// <summary>
        /// 浏览POI数据
        /// </summary>
        private void BrowsePOIData(object parameter)
        {
            var item = parameter as POIDataItem;
            if (item == null) return;

            var dialog = new OpenFileDialog
            {
                Filter = "所有支持格式|*.shp;*.tif;*.tiff;*.img|Shapefile (*.shp)|*.shp|Raster (*.tif;*.tiff;*.img)|*.tif;*.tiff;*.img|All Files (*.*)|*.*",
                Title = "选择POI数据或栅格"
            };

            if (dialog.ShowDialog() == true)
            {
                item.DataPath = dialog.FileName;
            }
        }

        /// <summary>
        /// 浏览输出路径
        /// </summary>
        private void BrowseOutputPath(object parameter)
        {
            var dialog = new SaveFileDialog
            {
                Filter = "Shapefile (*.shp)|*.shp",
                Title = "选择输出路径",
                FileName = "Result_Rating_Suitable_Area.shp"
            };

            if (dialog.ShowDialog() == true)
            {
                OutputPath = dialog.FileName;
            }
        }

        /// <summary>
        /// 检查是否可以运行分析
        /// </summary>
        private bool CanRunAnalysis(object parameter)
        {
            return !string.IsNullOrWhiteSpace(AnalysisAreaPath) &&
                   POIItems.Any(p => !p.IsEmpty) &&
                   !string.IsNullOrWhiteSpace(OutputPath);
        }

        /// <summary>
        /// 运行分析
        /// </summary>
        private void RunAnalysis(object parameter)
        {
            // 验证权重和
            var nonEmptyPOI = POIItems.Where(p => !p.IsEmpty).ToList();
            double weightSum = nonEmptyPOI.Sum(p => p.Weight ?? 0);

            if (Math.Abs(weightSum - 1.0) > 0.001)
            {
                MessageBox.Show($"权重之和必须为1.0，当前为{weightSum:F2}", "验证失败");
                return;
            }

            // 获取非空约束条件
            var validConstraints = ConstraintItems.Where(c => !c.IsEmpty).ToList();

            // 获取非空POI数据
            var validPOIs = POIItems.Where(p => !p.IsEmpty).ToList();

            // TODO: 调用Divide、Distance、Rating模块
            // 示例：
            // DivideModule.Execute(AnalysisAreaPath, validConstraints);
            // DistanceModule.Execute(validPOIs);
            // RatingModule.Execute(validPOIs, OutputPath);

            MessageBox.Show(
                $"开始运行选址分析...\n" +
                $"约束条件数量: {validConstraints.Count}\n" +
                $"POI数据数量: {validPOIs.Count}\n" +
                $"输出路径: {OutputPath}",
                "提示"
            );
        }

        #endregion

        #region DockPane方法

        internal static void Show()
        {
            DockPane pane = FrameworkApplication.DockPaneManager.Find(_dockPaneID);
            if (pane == null)
                return;

            pane.Activate();
        }

        #endregion
    }

    /// <summary>
    /// 按钮实现以显示DockPane
    /// </summary>
    internal class main_dockpane_ShowButton : Button
    {
        protected override void OnClick()
        {
            main_dockpaneViewModel.Show();
        }
    }
}
```

---

## 四、XAML界面（无需修改）

XAML界面保持与原方案一致，因为动态空行的逻辑完全由ViewModel和数据模型处理。

参考原方案中的 `main_dockpane.xaml` 即可。

---

## 五、核心改进对比

### 5.1 原方案（固定行数）

```csharp
// ❌ 问题：固定行数，无法动态扩展
private void InitializeCollections()
{
    ConstraintItems = new ObservableCollection<ConstraintDataItem>();
    for (int i = 0; i < 5; i++)  // 固定5行
    {
        ConstraintItems.Add(new ConstraintDataItem());
    }
}

// ❌ 问题：检查所有行，效率低且逻辑复杂
private void AutoAddEmptyRow<T>(ObservableCollection<T> collection) where T : new()
{
    bool allFilled = true;
    foreach (var item in collection)
    {
        if (item is ConstraintDataItem constraint && constraint.IsEmpty)
        {
            allFilled = false;
            break;
        }
    }

    if (allFilled)
    {
        collection.Add(new T());
    }
}
```

### 5.2 改进方案（动态空行）

```csharp
// ✅ 改进：初始化时只添加1个空白行
private void InitializeCollections()
{
    ConstraintItems = new ObservableCollection<ConstraintDataItem>();
    AddEmptyConstraintRow();  // 只添加1行
}

// ✅ 改进：订阅每个数据项的属性变化
private void AddEmptyConstraintRow()
{
    var newItem = new ConstraintDataItem();

    // 关键：订阅属性变化事件
    newItem.PropertyChanged += (sender, e) =>
    {
        if (e.PropertyName == nameof(ConstraintDataItem.DataPath))
        {
            CheckAndAddEmptyConstraintRow();
        }
    };

    ConstraintItems.Add(newItem);
}

// ✅ 改进：只检查最后一行，效率高
private void CheckAndAddEmptyConstraintRow()
{
    var lastItem = ConstraintItems.LastOrDefault();

    if (lastItem != null && !lastItem.IsEmpty)
    {
        AddEmptyConstraintRow();
    }
}
```

---

## 六、工作流程示例

### 6.1 约束条件动态添加流程

```
初始状态：
[空白行1]

用户填充空白行1 → 触发PropertyChanged事件 → 检查最后一行 → 最后一行非空 → 添加空白行2
[已填充行1]
[空白行2]

用户填充空白行2 → 触发PropertyChanged事件 → 检查最后一行 → 最后一行非空 → 添加空白行3
[已填充行1]
[已填充行2]
[空白行3]

...以此类推，理论上可以添加无限行
```

### 6.2 POI数据动态添加流程

```
初始状态：
[空白行1]

用户填充空白行1 → 触发PropertyChanged(DataPath) → 自动识别栅格/矢量 → 检查最后一行 → 添加空白行2
同时触发PropertyChanged(Weight) → 验证权重和
[已填充行1 | 距离:100 | 权重:0.15 | 自定义:否]
[空白行2]

用户继续填充...
[已填充行1 | 距离:100 | 权重:0.15 | 自定义:否]
[已填充行2 | 距离:200 | 权重:0.25 | 自定义:是]
[已填充行3 | 栅格数据 | 距离:禁用 | 权重:0.60 | 自定义:否]
[空白行4]

权重和验证：0.15 + 0.25 + 0.60 = 1.00 ✅
```

---

## 七、关键技术点

### 7.1 事件订阅时机

```csharp
// ✅ 正确：在添加到集合之前订阅事件
var newItem = new ConstraintDataItem();
newItem.PropertyChanged += (sender, e) => { /* 处理逻辑 */ };
ConstraintItems.Add(newItem);

// ❌ 错误：在添加到集合之后订阅（可能错过事件）
ConstraintItems.Add(new ConstraintDataItem());
ConstraintItems.Last().PropertyChanged += ...;  // 不推荐
```

### 7.2 空白行判断逻辑

```csharp
// 在Model中定义
public bool IsEmpty => string.IsNullOrWhiteSpace(DataPath);

// 在ViewModel中使用
var validItems = POIItems.Where(p => !p.IsEmpty).ToList();
```

### 7.3 权重验证触发

```csharp
// 订阅Weight属性变化
newItem.PropertyChanged += (sender, e) =>
{
    if (e.PropertyName == nameof(POIDataItem.Weight))
    {
        ValidateWeightSum();  // 每次权重变化时重新验证
    }
};
```

---

## 八、测试建议

### 8.1 功能测试

1. **空白行自动添加**
   - 填充第1行 → 检查是否自动添加第2行
   - 连续填充10行 → 检查是否始终保持1个空白行在末尾

2. **空白行过滤**
   - 填充3行数据，保留2个空白行
   - 点击运行 → 检查是否只处理3行数据

3. **权重实时验证**
   - 输入权重0.5 → 检查提示"权重之和为0.50，应为1.0"
   - 继续输入权重0.5 → 检查提示消失

4. **栅格数据识别**
   - 选择.tif文件 → 检查距离字段是否自动禁用
   - 选择.shp文件 → 检查距离字段是否可编辑

### 8.2 性能测试

1. 添加100行约束条件数据
2. 添加50行POI数据
3. 检查界面响应速度
4. 检查内存占用情况

---

## 九、优势总结

| 特性 | 原方案 | 改进方案 |
|------|--------|----------|
| 初始行数 | 固定（5行约束+2行POI） | 动态（各1个空白行） |
| 扩展性 | 受限于初始行数 | 无限扩展 |
| 空白行管理 | 手动检查所有行 | 事件驱动，只检查最后一行 |
| 性能 | O(n) 遍历 | O(1) 检查 |
| 代码复杂度 | 较高（泛型+类型判断） | 较低（专用方法） |
| 用户体验 | 初始界面较空 | 简洁，按需扩展 |

---

## 十、后续集成说明

在 `RunAnalysis` 方法中，已经提供了获取有效数据的示例：

```csharp
// 获取非空约束条件
var validConstraints = ConstraintItems.Where(c => !c.IsEmpty).ToList();

// 获取非空POI数据
var validPOIs = POIItems.Where(p => !p.IsEmpty).ToList();

// 传递给功能模块
DivideModule.Execute(AnalysisAreaPath, validConstraints);
DistanceModule.Execute(validPOIs);
RatingModule.Execute(validPOIs, OutputPath);
```

---

## 十一、注意事项

1. **内存管理**：由于每个数据项都订阅了事件，删除数据时需要取消订阅以避免内存泄漏（当前方案中数据项不支持删除，如需支持请添加事件取消订阅逻辑）

2. **线程安全**：如果在后台线程修改数据，需要使用Dispatcher调度到UI线程

3. **性能优化**：如果数据量特别大（>1000行），考虑使用虚拟化技术（VirtualizingStackPanel）

---

**方案完成日期**: 2025-10-04
**改进版本**: v2.0 - 动态空行
